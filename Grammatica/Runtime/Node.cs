// <copyright file="Node.cs" company="None">
//    <para>
//    This program is free software: you can redistribute it and/or
//    modify it under the terms of the BSD license.</para>
//    <para>
//    This work is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</para>
//    <para>
//    See the LICENSE.txt file for more details.</para>
//    Original code as generated by Grammatica 1.6 Copyright (c) 
//    2003-2015 Per Cederberg. All rights reserved.
//    Updates Copyright (c) 2016 Jeremy Gibbons. All rights reserved
// </copyright>

namespace PerCederberg.Grammatica.Runtime
{
   using System.Collections;
   using System.Collections.Generic;
   using System.IO;

   /// <summary>
   /// An abstract parse tree node. This class is inherited by all
   /// nodes in the parse tree, i.e. by the token and production
   /// classes.
   /// </summary>
   public abstract class Node
   {
      /// <summary>
      /// The parent node.
      /// </summary>
      private Node parent = null;

      /// <summary>
      /// The computed node values.
      /// </summary>
      private ArrayList values = null;

      /// <summary>
      /// Gets the node type id (read-only). This value is set as
      /// a unique identifier for each type of node, in order to
      /// simplify later identification.
      /// </summary>
      public abstract int Id
      {
         get;
      }

      /// <summary>
      /// Gets the node name (read-only).
      /// </summary>
      public abstract string Name
      {
         get;
      }

      /// <summary>
      /// Gets the line number of the first character in this
      /// node (read-only). If the node has child elements, this
      /// value will be fetched from the first child.
      /// </summary>
      public virtual int StartLine
      {
         get
         {
            int line;

            for (int i = 0; i < this.ChildCount; i++)
            {
               line = this[i].StartLine;
               if (line >= 0)
               {
                  return line;
               }
            }

            return -1;
         }
      }

      /// <summary>
      /// Gets the column number of the first character in this
      /// node (read-only). If the node has child elements, this
      /// value will be fetched from the first child.
      /// </summary>
      public virtual int StartColumn
      {
         get
         {
            int col;

            for (int i = 0; i < this.ChildCount; i++)
            {
               col = this[i].StartColumn;
               if (col >= 0)
               {
                  return col;
               }
            }

            return -1;
         }
      }

      /// <summary>
      /// Gets the line number of the last character in this node
      /// (read-only). If the node has child elements, this value
      /// will be fetched from the last child.
      /// </summary>       
      public virtual int EndLine
      {
         get
         {
            int line;

            for (int i = this.ChildCount - 1; i >= 0; i--)
            {
               line = this[i].EndLine;
               if (line >= 0)
               {
                  return line;
               }
            }

            return -1;
         }
      }

      /// <summary>
      /// Gets the column number of the last character in this
      /// node (read-only). If the node has child elements, this
      /// value will be fetched from the last child.
      /// </summary>
      public virtual int EndColumn
      {
         get
         {
            int col;

            for (int i = this.ChildCount - 1; i >= 0; i--)
            {
               col = this[i].EndColumn;
               if (col >= 0)
               {
                  return col;
               }
            }

            return -1;
         }
      }

      /// <summary>
      /// Gets or sets the parent node
      /// </summary>
      public Node Parent
      {
         get
         {
            return this.parent;
         }

         set
         {
            this.parent = value;
         }
      }

      /// <summary>
      /// Gets child node count (read-only).
      /// </summary>
      public virtual int ChildCount
      {
         get
         {
            return 0;
         }
      }

      /// <summary>
      /// Gets the number of descendant nodes.
      /// </summary>
      public int DescendantCount
      {
         get
         {
            int count = 0;

            for (int i = 0; i < this.ChildCount; i++)
            {
               count += 1 + this[i].DescendantCount;
            }

            return count;
         }
      }

      /// <summary>
      /// Gets or sets the node values. This property provides direct
      /// access to the list of computed values associated with this
      /// node during analysis. Note that setting this property to
      /// null will remove all node values. Any operation on the
      /// value array list is allowed and is immediately reflected
      /// through the various value reading and manipulation methods.
      /// </summary>
      public ArrayList Values
      {
         get
         {
            if (this.values == null)
            {
               this.values = new ArrayList();
            }

            return this.values;
         }

         set
         {
            this.values = value;
         }
      }

      /// <summary>
      /// Gets the list of children as an IList of Node
      /// </summary>
      public virtual IList<Node> Children
      {
         get
         {
            return new List<Node>();
         }
      }

      /// <summary>
      /// Gets a value indicating whether this node is 
      /// hidden, i.e. if it should not be visible outside the parser.
      /// </summary>
      internal virtual bool Hidden
      {
         get
         {
            return false;
         }
      }

      /// <summary>
      /// Gets the child node index (read-only).
      /// </summary>
      /// <param name="index">The child index from 0 to ChildCount - 1</param>
      /// <returns>The child at the given index</returns>
      public virtual Node this[int index]
      {
         get
         {
            return null;
         }
      }

      /// <summary>
      /// Prints this node and all sub-nodes to the specified output
      /// stream.
      /// </summary>
      /// <param name="output">The output stream to use</param>      
      public void PrintTo(TextWriter output)
      {
         this.PrintTo(output, string.Empty);
         output.Flush();
      }

      /// <summary>
      /// Prints this node and all sub-nodes to the specified output
      /// stream.
      /// </summary>
      /// <param name="output">The output stream to use</param>
      /// <param name="indent">The indentation string</param>
      private void PrintTo(TextWriter output, string indent)
      {
         output.WriteLine(indent + ToString());
         indent += "  ";
         for (int i = 0; i < this.ChildCount; i++)
         {
            this[i].PrintTo(output, indent);
         }
      }
   }
}
