// <copyright file="NFAState.cs" company="None">
//    <para>
//    This program is free software: you can redistribute it and/or
//    modify it under the terms of the BSD license.</para>
//    <para>
//    This work is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</para>
//    <para>
//    See the LICENSE.txt file for more details.</para>
//    Original code as generated by Grammatica 1.6 Copyright (c) 
//    2003-2015 Per Cederberg. All rights reserved.
//    Updates Copyright (c) 2016 Jeremy Gibbons. All rights reserved
// </copyright>

namespace PerCederberg.Grammatica.Runtime.NFA
{
   using PerCederberg.Grammatica.Runtime;
   using System.Collections.Generic;
   using System.Linq;

   /// <summary>
   /// An NFA state. The NFA consists of a series of states, each
   /// having zero or more transitions to other states.
   /// </summary>
   internal class NFAState
   {
      /// <summary>
      /// The optional state value (if it is a final state).
      /// </summary>    
      private TokenPattern value = null;

      /// <summary>
      /// The incoming transitions to this state.
      /// </summary>
      private List<NFATransition> incoming = new List<NFATransition>();

      /// <summary>
      /// The outgoing transitions from this state.
      /// </summary>
      private List<NFATransition> outgoing = new List<NFATransition>();

      /// <summary>
      /// The outgoing epsilon transitions flag.
      /// </summary>
      private bool epsilonOut = false;

      /// <summary>
      /// Gets a value indicating whether this state has any incoming or outgoing
      /// transitions.
      /// </summary>
      public bool HasTransitions
      {
         get
         {
            return this.incoming.Count > 0 || this.outgoing.Count > 0;
         }
      }

      /// <summary>
      /// Gets a value indicating whether all outgoing transitions only match ASCII
      /// characters.
      /// </summary>
      public bool IsAsciiOutgoing
      {
         get
         {
            return this.outgoing.All(o => o.IsAscii);
         }
      }

      /// <summary>
      /// Gets a value indicating whether the state has outgoing epsilon 
      /// transitions
      /// </summary>
      internal bool EpsilonOut
      {
         get
         {
            return this.epsilonOut;
         }
      }

      /// <summary>
      /// Gets the list of incoming transitions to the state
      /// </summary>
      internal List<NFATransition> Incoming
      {
         get
         {
            return this.incoming;
         }
      }

      /// <summary>
      /// Gets the list of outgoing transitions from the state.
      /// </summary>
      internal List<NFATransition> Outgoing
      {
         get
         {
            return this.outgoing;
         }
      }

      /// <summary>
      /// Gets or sets the optional state value (if this is a final state)
      /// </summary>
      internal TokenPattern Value
      {
         get
         {
            return this.value;
         }

         set
         {
            this.value = value;
         }
      }

      /// <summary>
      /// Adds a new incoming transition.
      /// </summary>
      /// <param name="trans">The transition to add</param>
      public void AddIn(NFATransition trans)
      {
         this.incoming.Add(trans);
      }

      /// <summary>
      /// Adds a new outgoing character transition. If the target
      /// state specified was null and an identical transition
      /// already exists, it will be reused and its target returned.
      /// </summary>
      /// <param name="ch">The character to match</param>
      /// <param name="ignoreCase">The case-insensitive flag</param>
      /// <param name="state">The target state, or null</param>
      /// <returns>The transition target state</returns>
      public NFAState AddOut(char ch, bool ignoreCase, NFAState state)
      {
         if (ignoreCase)
         {
            if (state == null)
            {
               state = new NFAState();
            }

            this.AddOut(new NFACharTransition(char.ToLower(ch), state));
            this.AddOut(new NFACharTransition(char.ToUpper(ch), state));
            return state;
         }
         else
         {
            if (state == null)
            {
               state = this.FindUniqueCharTransition(ch);
               if (state != null)
               {
                  return state;
               }

               state = new NFAState();
            }

            return this.AddOut(new NFACharTransition(ch, state));
         }
      }

      /// <summary>
      /// Adds a new outgoing transition.
      /// </summary>
      /// <param name="trans">The transition to add</param>
      /// <returns>The transition target state</returns>
      public NFAState AddOut(NFATransition trans)
      {
         this.outgoing.Add(trans);

         if (trans is NFAEpsilonTransition)
         {
            this.epsilonOut = true;
         }

         return trans.State;
      }

      /// <summary>
      /// Merges all the transitions in this state into another
      /// state.
      /// </summary>
      /// <param name="state">The state to merge into</param>
      public void MergeInto(NFAState state)
      {
         foreach (var inTrans in this.incoming)
         {
            state.AddIn(inTrans);
            inTrans.State = state;
         }

         this.incoming = null;

         foreach (var outTrans in this.outgoing)
         {
            state.AddOut(outTrans);
         }

         this.outgoing = null;
      }

      /// <summary>
      /// Attempts a match on each of the transitions leading from
      /// this state. If a match is found, its state will be added
      /// to the queue. If the initial match flag is set, epsilon
      /// transitions will also be matched (and their targets called
      /// recursively).
      /// </summary>
      /// <param name="ch">The character to match</param>
      /// <param name="queue">The state queue</param>
      /// <param name="initial">The initial match flag</param>
      public void MatchTransitions(char ch, NFAStateQueue queue, bool initial)
      {
         NFAState target;
         foreach (var trans in this.outgoing)
         {
            target = trans.State;
            if (initial && trans is NFAEpsilonTransition)
            {
               target.MatchTransitions(ch, queue, true);
            }
            else if (trans.Match(ch))
            {
               queue.AddLast(target);
               if (target.epsilonOut)
               {
                  target.MatchEmpty(queue);
               }
            }
         }
      }

      /// <summary>
      /// Adds all the epsilon transition targets to the specified
      /// queue.
      /// </summary>
      /// <param name="queue">The state queue</param>
      public void MatchEmpty(NFAStateQueue queue)
      {
         NFAState target;

         foreach (var trans in this.outgoing)
         {
            if (trans is NFAEpsilonTransition)
            {
               target = trans.State;
               queue.AddLast(target);
               if (target.epsilonOut)
               {
                  target.MatchEmpty(queue);
               }
            }
         }
      }

      /// <summary>
      /// Finds a unique character transition if one exists. The
      /// transition must be the only matching single character
      /// transition and no other transitions may reach the same
      /// state.
      /// </summary>
      /// <param name="ch">The character to search for</param>
      /// <returns>
      /// The unique transition state found, or null if none was found
      /// </returns>
      private NFAState FindUniqueCharTransition(char ch)
      {
         NFATransition res = null;

         foreach (var trans in this.outgoing)
         {
            if (trans.Match(ch) && trans is NFACharTransition)
            {
               if (res != null)
               {
                  return null;
               }

               res = trans;
            }
         }

         if (res == null)
         {
            return null;
         }

         foreach (var trans in this.outgoing)
         {
            if (trans != res && trans.State == res.State)
            {
               return null;
            }
         }

         return res?.State;
      }
   }
}
