// <copyright file="Tokenizer.cs" company="None">
//    <para>
//    This program is free software: you can redistribute it and/or
//    modify it under the terms of the BSD license.</para>
//    <para>
//    This work is distributed in the hope that it will be useful, but
//    WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</para>
//    <para>
//    See the LICENSE.txt file for more details.</para>
//    Original code as generated by Grammatica 1.6 Copyright (c) 
//    2003-2015 Per Cederberg. All rights reserved.
//    Updates Copyright (c) 2016 Jeremy Gibbons. All rights reserved
// </copyright>

namespace PerCederberg.Grammatica.Runtime
{
   using PerCederberg.Grammatica.Runtime.RE;
   using System;
   using System.Collections.Generic;
   using System.IO;
   using System.Linq;
   using System.Text;
   using System.Text.RegularExpressions;

   /// <summary>
   /// A character stream tokenizer. This class groups the characters read
   /// from the stream together into tokens ("words"). The grouping is
   /// controlled by token patterns that contain either a fixed string to
   /// search for, or a regular expression. If the stream of characters
   /// don't match any of the token patterns, a parse exception is thrown.
   /// </summary>
   public class Tokenizer
   {
      /// <summary>
      /// The token list feature flag.
      /// </summary> 
      private bool useTokenList = false;

      /// <summary>
      /// The string DFA token matcher. This token matcher uses a
      /// deterministic finite automaton (DFA) implementation and is
      /// used for all string token patterns. It has a slight speed
      /// advantage to the NFA implementation, but should be equivalent
      /// on memory usage.
      /// </summary>
      private readonly StringDFAMatcher stringDfaMatcher;

      /// <summary>
      /// The regular expression NFA token matcher. This token matcher
      /// uses a non-deterministic finite automaton (DFA) implementation
      /// and is used for most regular expression token patterns. It is
      /// somewhat faster than the other recursive regular expression
      /// implementations available, but doesn't support the full
      /// syntax. It conserves memory by using a fast queue instead of
      /// the stack during processing (no stack overflow).
      /// </summary>
      private readonly NFAMatcher nfaMatcher;

      /// <summary>
      /// The regular expression token matcher. This token matcher is
      /// used for complex regular expressions, but should be avoided
      /// due to possibly degraded speed and memory usage compared to
      /// the automaton implementations.
      /// </summary>
      private readonly RegExpMatcher regExpMatcher;

      /// <summary>
      /// The character stream reader buffer.
      /// </summary>
      private ReaderBuffer buffer = null;

      /// <summary>
      /// The last token match found.
      /// </summary>
      private readonly TokenMatch lastMatch = new TokenMatch();

      /// <summary>
      /// The previous token in the token list.
      /// </summary>
      private Token previousToken = null;

      /// <summary>
      /// Initializes a new instance of the <see cref="Tokenizer"/> class, i.e. 
      /// a new case-sensitive tokenizer for the specified input stream.
      /// </summary>
      /// <param name="input">The input stream to read</param>
      public Tokenizer(TextReader input)
          : this(input, false)
      {
      }

      /// <summary>
      /// Initializes a new instance of the <see cref="Tokenizer"/> class
      /// for the specified input stream. The tokenizer can be set to process 
      /// tokens either in case-sensitive or case-insensitive mode.
      /// </summary>
      /// <param name="input">The input stream to read</param>
      /// <param name="ignoreCase">The character case ignore flag</param>
      public Tokenizer(TextReader input, bool ignoreCase)
      {
         this.stringDfaMatcher = new StringDFAMatcher(ignoreCase);
         this.nfaMatcher = new NFAMatcher(ignoreCase);
         this.regExpMatcher = new RegExpMatcher(ignoreCase);
         this.buffer = new ReaderBuffer(input);
      }

      /// <summary>
      /// Gets or sets a value indicating whether use a token list.
      /// If the token list flag is set, all tokens (including ignored 
      /// tokens) link to each other in a double-linked list. 
      /// By default the token list flag is set to false.
      /// </summary>
      /// <see cref="Token.Previous"/>
      /// <see cref="Token.Next"/>
      public bool UseTokenList
      {
         get
         {
            return this.useTokenList;
         }

         set
         {
            this.useTokenList = value;
         }
      }

      /// <summary>
      /// Gets the current line number. This number will be the line
      /// number of the next token returned.
      /// </summary>
      public int CurrentLine
      {
         get
         {
            return this.buffer.LineNumber;
         }
      }

      /// <summary>
      /// Gets the current column number. This number will be the
      /// column number of the next token returned.
      /// </summary>
      public int CurrentColumn
      {
         get
         {
            return this.buffer.ColumnNumber;
         }
      }

      /// <summary>
      /// Returns a description of the token pattern with the
      /// specified id.
      /// </summary>
      /// <param name="id">The token pattern id</param>
      /// <returns>The token pattern description, or null if not present</returns>
      public string GetPatternDescription(int id)
      {
         TokenPattern pattern;

         pattern = this.stringDfaMatcher.GetPattern(id);

         if (pattern == null)
         {
            pattern = this.nfaMatcher.GetPattern(id);
         }

         if (pattern == null)
         {
            pattern = this.regExpMatcher.GetPattern(id);
         }

         return pattern?.ToShortString();
      }

      /// <summary>
      /// Adds a new token pattern to the tokenizer. The pattern will be
      /// added last in the list, choosing a previous token pattern in
      /// case two matches the same string.
      /// </summary>
      /// <param name="pattern">The pattern to add</param>
      /// <exception cref="ParserCreationException">
      /// If the pattern couldn't be added to the tokenizer
      /// </exception>
      public void AddPattern(TokenPattern pattern)
      {
         switch (pattern.Type)
         {
            case TokenPattern.PatternType.String:
               try
               {
                  this.stringDfaMatcher.AddPattern(pattern);
               }
               catch (Exception e)
               {
                  throw new ParserCreationException(
                      ParserCreationException.ErrorType.InvalidToken,
                      pattern.Name,
                      "error adding string token: " +
                      e.Message);
               }

               break;
            case TokenPattern.PatternType.RegExp:
               try
               {
                  this.nfaMatcher.AddPattern(pattern);
               }
               catch (Exception)
               {
                  try
                  {
                     this.regExpMatcher.AddPattern(pattern);
                  }
                  catch (Exception e)
                  {
                     throw new ParserCreationException(
                         ParserCreationException.ErrorType.InvalidToken,
                         pattern.Name,
                         "regular expression contains error(s): " +
                         e.Message);
                  }
               }

               break;
            default:
               throw new ParserCreationException(
                   ParserCreationException.ErrorType.InvalidToken,
                   pattern.Name,
                   "pattern type " + pattern.Type + " is undefined");
         }
      }

      /// <summary>
      /// Resets this tokenizer for usage with another input stream.
      /// This method will clear all the internal state in the
      /// tokenizer as well as close the previous input stream. It
      /// is normally called in order to reuse a parser and
      /// tokenizer pair with multiple input streams, thereby
      /// avoiding the cost of re-analyzing the grammar structures.
      /// </summary>
      /// <param name="input">The new input stream to read</param>
      /// <see cref="Parser.Reset(TextReader)"/>
      public void Reset(TextReader input)
      {
         this.buffer.Reset();
         this.buffer = new ReaderBuffer(input);
         this.previousToken = null;
         this.lastMatch.Clear();
      }

      /// <summary>
      /// Finds the next token on the stream. This method will return
      /// null when end of file has been reached. It will return a
      /// parse exception if no token matched the input stream, or if
      /// a token pattern with the error flag set matched. Any tokens
      /// matching a token pattern with the ignore flag set will be
      /// silently ignored and the next token will be returned.
      /// </summary>
      /// <returns>The next token found, or null if end of file was encountered</returns>
      /// <exception cref="ParseException">
      /// If the input stream couldn't be read or parsed correctly
      /// </exception>
      public Token Next()
      {
         Token token;

         do
         {
            token = this.NextToken();
            if (token == null)
            {
               this.previousToken = null;
               return null;
            }

            if (this.useTokenList)
            {
               token.Previous = this.previousToken;
               this.previousToken = token;
            }

            if (token.Pattern.Ignore)
            {
               token = null;
            }
            else if (token.Pattern.Error)
            {
               throw new ParseException(
                   ParseException.ErrorType.InvalidToken,
                   token.Pattern.ErrorMessage,
                   token.StartLine,
                   token.StartColumn);
            }
         }
         while (token == null);

         return token;
      }

      /// <summary>
      /// Returns a string representation of this object. The returned
      /// string will contain the details of all the token patterns
      /// contained in this tokenizer.
      /// </summary>
      /// <returns>A detailed string representation</returns>
      public override string ToString()
      {
         StringBuilder builder = new StringBuilder();

         builder.Append(this.stringDfaMatcher);
         builder.Append(this.nfaMatcher);
         builder.Append(this.regExpMatcher);
         return builder.ToString();
      }

      /// <summary>
      /// Factory method for creating a new token. This method can be
      /// overridden to provide other token implementations than the
      /// default one.
      /// </summary>
      /// <param name="pattern">The token pattern</param>
      /// <param name="image">The token image (i.e. characters)</param>
      /// <param name="line">The line number of the first character</param>
      /// <param name="column">The column number of the first character</param>
      /// <returns>The created token</returns>
      protected virtual Token NewToken(
          TokenPattern pattern,
          string image,
          int line,
          int column)
      {
         return new Token(pattern, image, line, column);
      }

      /// <summary>
      /// Finds the next token on the stream. This method will return
      /// null when end of file has been reached. It will return a
      /// parse exception if no token matched the input stream.
      /// </summary>
      /// <returns>The next token found, or null if EOF was encountered</returns>
      /// <exception cref="ParseException">
      /// If the input stream couldn't be read or parsed correctly
      /// </exception>
      private Token NextToken()
      {
         string str;
         int line;
         int column;

         try
         {
            this.lastMatch.Clear();
            this.stringDfaMatcher.Match(this.buffer, this.lastMatch);
            this.nfaMatcher.Match(this.buffer, this.lastMatch);
            this.regExpMatcher.Match(this.buffer, this.lastMatch);
            if (this.lastMatch.Length > 0)
            {
               line = this.buffer.LineNumber;
               column = this.buffer.ColumnNumber;
               str = this.buffer.Read(this.lastMatch.Length);
               return this.NewToken(this.lastMatch.Pattern, str, line, column);
            }
            else if (this.buffer.Peek(0) < 0)
            {
               return null;
            }
            else
            {
               line = this.buffer.LineNumber;
               column = this.buffer.ColumnNumber;
               throw new ParseException(
                   ParseException.ErrorType.UnexpectedChar,
                   this.buffer.Read(1),
                   line,
                   column);
            }
         }
         catch (IOException e)
         {
            throw new ParseException(
                ParseException.ErrorType.IO,
                e.Message,
                -1,
                -1);
         }
      }

      /// <summary>
      /// A token pattern matcher. This class is the base class for the
      /// various types of token matchers that exist. The token matcher
      /// checks for matches with the tokenizer buffer, and maintains the
      /// state of the last match.
      /// </summary>
      internal abstract class TokenMatcher
      {
         /// <summary>
         /// The array of token patterns.
         /// </summary>
         private readonly IList<TokenPattern> patterns = new List<TokenPattern>();

         /// <summary>
         /// The ignore character case flag.
         /// </summary>
         private readonly bool ignoreCase = false;

         /// <summary>
         /// Initializes a new instance of the <see cref="TokenMatcher"/> class.
         /// </summary>
         /// <param name="ignoreCase">The character case ignore flag</param>
         public TokenMatcher(bool ignoreCase)
         {
            this.ignoreCase = ignoreCase;
         }

         /// <summary>
         /// Gets a value indicating whether to ignore case
         /// </summary>
         protected bool IgnoreCase
         {
            get
            {
               return this.ignoreCase;
            }
         }

         /// <summary>
         /// Gets the list of patterns
         /// </summary>
         protected IList<TokenPattern> Patterns
         {
            get
            {
               return this.patterns;
            }
         }

         /// <summary>
         /// Searches for matching token patterns at the start of the
         /// input stream. If a match is found, the token match object
         /// is updated.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <param name="match">The token match to update</param>
         /// <exception cref="IOException">If an I/O error occurred</exception>
         public abstract void Match(ReaderBuffer buffer, TokenMatch match);

         /// <summary>
         /// Returns the token pattern with the specified id. Only
         /// token patterns handled by this matcher can be returned.
         /// </summary>
         /// <param name="id">The token pattern id</param>
         /// <returns>The token pattern found, or null if not found</returns>
         public TokenPattern GetPattern(int id)
         {
            return this.patterns.Where(p => p.Id == id).SingleOrDefault();
         }

         /// <summary>
         /// Adds a string token pattern to this matcher.
         /// </summary>
         /// <param name="pattern">The pattern to add</param>
         /// <exception cref="Exception">If the pattern couldn't be added to the matcher</exception>
         public virtual void AddPattern(TokenPattern pattern)
         {
            this.patterns.Add(pattern);
         }

         /// <summary>
         /// Returns a string representation of this matcher. This will
         /// contain all the token patterns.
         /// </summary>
         /// <returns>A detailed string representation of this matcher</returns>
         public override string ToString()
         {
            StringBuilder buffer = new StringBuilder();

            foreach (var p in this.patterns)
            {
               buffer.Append(p);
               buffer.Append("\n\n");
            }

            return buffer.ToString();
         }
      }

      /// <summary>
      /// A token pattern matcher using a DFA for string tokens. This
      /// class only supports string tokens and must be complemented
      /// with another matcher for regular expressions. Internally it
      /// uses a DFA to provide high performance.
      /// </summary>
      internal class StringDFAMatcher : TokenMatcher
      {
         /// <summary>
         /// The deterministic finite state automaton used for
         /// matching.
         /// </summary>
         private readonly TokenStringDFA automaton = new TokenStringDFA();

         /// <summary>
         /// Initializes a new instance of the <see cref="StringDFAMatcher"/> class.
         /// </summary>
         /// <param name="ignoreCase">The character case ignore flag</param>
         public StringDFAMatcher(bool ignoreCase) : base(ignoreCase)
         {
         }

         /// <summary>
         /// Adds a string token pattern to this matcher.
         /// </summary>
         /// <param name="pattern">The pattern to add</param>
         public override void AddPattern(TokenPattern pattern)
         {
            this.automaton.AddMatch(pattern.Pattern, this.IgnoreCase, pattern);
            base.AddPattern(pattern);
         }

         /// <summary>
         /// Searches for matching token patterns at the start of the
         /// input stream. If a match is found, the token match object
         /// is updated.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <param name="match">The token match to update</param>
         /// <exception cref="IOException">If an error occurred</exception>
         public override void Match(ReaderBuffer buffer, TokenMatch match)
         {
            TokenPattern res = this.automaton.Match(buffer, this.IgnoreCase);

            if (res != null)
            {
               match.Update(res.Pattern.Length, res);
            }
         }
      }

      /// <summary>
      /// A token pattern matcher using a NFA for both string and
      /// regular expression tokens. This class has limited support for
      /// regular expressions and must be complemented with another
      /// matcher providing full regular expression support. Internally
      /// it uses a NFA to provide high performance and low memory
      /// usage.
      /// </summary>
      internal class NFAMatcher : TokenMatcher
      {
         /// <summary>
         /// The non-deterministic finite state automaton used for
         /// matching.
         /// </summary>
         private readonly TokenNFA automaton = new TokenNFA();

         /// <summary>
         /// Initializes a new instance of the <see cref="NFAMatcher"/> class.
         /// </summary>
         /// <param name="ignoreCase">The character case ignore flag</param>
         public NFAMatcher(bool ignoreCase) : base(ignoreCase)
         {
         }

         /// <summary>
         /// Adds a token pattern to this matcher.
         /// </summary>
         /// <param name="pattern">The pattern to add</param>
         /// <exception cref="Exception">
         /// If the pattern couldn't be added to the matcher
         /// </exception>
         public override void AddPattern(TokenPattern pattern)
         {
            if (pattern.Type == TokenPattern.PatternType.String)
            {
               this.automaton.AddTextMatch(pattern.Pattern, this.IgnoreCase, pattern);
            }
            else
            {
               this.automaton.AddRegExpMatch(pattern.Pattern, this.IgnoreCase, pattern);
            }

            base.AddPattern(pattern);
         }

         /// <summary>
         /// Searches for matching token patterns at the start of the
         /// input stream. If a match is found, the token match object
         /// is updated.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <param name="match">The token match to update</param>
         /// <exception cref="IOException">If an I/O error occurred</exception>
         public override void Match(ReaderBuffer buffer, TokenMatch match)
         {
            this.automaton.Match(buffer, match);
         }
      }

      /// <summary>
      /// A token pattern matcher for complex regular expressions. This
      /// class only supports regular expression tokens and must be
      /// complemented with another matcher for string tokens.
      /// Internally it uses the <c>GrammaticaRE</c> package for high
      /// performance or the native .NET package for maximum
      /// compatibility.
      /// </summary>
      internal class RegExpMatcher : TokenMatcher
      {
         /// <summary>
         /// The regular expression handlers.
         /// </summary>
         private REHandler[] regExps = new REHandler[0];

         /// <summary>
         /// Initializes a new instance of the <see cref="RegExpMatcher"/> class.
         /// </summary>
         /// <param name="ignoreCase">The character case ignore flag</param>
         public RegExpMatcher(bool ignoreCase) : base(ignoreCase)
         {
         }

         /// <summary>
         /// Adds a regular expression token pattern to this matcher.
         /// </summary>
         /// <param name="pattern">The pattern to add</param>
         /// <exception cref="Exception">
         /// If the pattern couldn't be added to the matcher
         /// </exception>
         public override void AddPattern(TokenPattern pattern)
         {
            REHandler re;

            try
            {
               re = new GrammaticaRE(pattern.Pattern, this.IgnoreCase);
               pattern.DebugInfo = "Grammatica regexp\n" + re;
            }
            catch (Exception)
            {
               re = new SystemRE(pattern.Pattern, this.IgnoreCase);
               pattern.DebugInfo = "native .NET regexp";
            }

            Array.Resize(ref this.regExps, this.regExps.Length + 1);
            this.regExps[this.regExps.Length - 1] = re;
            base.AddPattern(pattern);
         }

         /// <summary>
         /// Searches for matching token patterns at the start of the
         /// input stream. If a match is found, the token match object
         /// is updated.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <param name="match">The token match to update</param>
         /// <exception cref="IOException">If an I/O error occurred</exception>
         public override void Match(ReaderBuffer buffer, TokenMatch match)
         {
            for (int i = 0; i < this.regExps.Length; i++)
            {
               int length = this.regExps[i].Match(buffer);
               if (length > 0)
               {
                  match.Update(length, this.Patterns[i]);
               }
            }
         }
      }

      /// <summary>
      /// The regular expression handler base class.
      /// </summary>
      internal abstract class REHandler
      {
         /// <summary>
         /// Checks if the start of the input stream matches this
         /// regular expression.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <returns>The longest match found, or 0 if none was found</returns>
         /// <exception cref="IOException">If an I/O error occurred</exception>
         public abstract int Match(ReaderBuffer buffer);
      }

      /// <summary>
      /// The Grammatica built-in regular expression handler.
      /// </summary>
      internal class GrammaticaRE : REHandler
      {
         /// <summary>
         /// The compiled regular expression.
         /// </summary>
         private readonly RegExp regExp;

         /// <summary>
         /// The regular expression matcher to use.
         /// </summary>
         private Matcher matcher = null;

         /// <summary>
         /// Initializes a new instance of the <see cref="GrammaticaRE"/> class.
         /// </summary>
         /// <param name="regex">The regular expression text</param>
         /// <param name="ignoreCase">The character case ignore flag</param>
         /// <exception cref="Exception">
         /// If the regular expression contained invalid syntax
         /// </exception>
         public GrammaticaRE(string regex, bool ignoreCase)
         {
            this.regExp = new RegExp(regex, ignoreCase);
         }

         /// <summary>
         /// Checks if the start of the input stream matches this
         /// regular expression.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <returns>The longest match found, or 0 if none was found</returns>
         /// <exception cref="IOException">If an I/O error occurred</exception>
         public override int Match(ReaderBuffer buffer)
         {
            if (this.matcher == null)
            {
               this.matcher = this.regExp.Matcher(buffer);
            }
            else
            {
               this.matcher.Reset(buffer);
            }

            return this.matcher.MatchFromBeginning() ? this.matcher.Length : 0;
         }
      }

      /// <summary>
      /// The .NET system regular expression handler.
      /// </summary>
      internal class SystemRE : REHandler
      {
         /// <summary>
         /// The parsed regular expression.
         /// </summary>
         private readonly Regex reg;

         /// <summary>
         /// Initializes a new instance of the <see cref="SystemRE"/> class, i.e.
         /// a new .NET system regular expression handler.
         /// </summary>
         /// <param name="regex">The regular expression text</param>
         /// <param name="ignoreCase">The character case ignore flag</param>
         /// <exception cref="Exception">If the regular expression contained invalid syntax</exception>
         public SystemRE(string regex, bool ignoreCase)
         {
            if (ignoreCase)
            {
               this.reg = new Regex(regex, RegexOptions.IgnoreCase);
            }
            else
            {
               this.reg = new Regex(regex);
            }
         }

         /// <summary>
         /// Checks if the start of the input stream matches this
         /// regular expression.
         /// </summary>
         /// <param name="buffer">The input buffer to check</param>
         /// <returns>The longest match found, or 0 if no match was found</returns>
         /// <exception cref="IOException">If an I/O error occurred</exception>
         public override int Match(ReaderBuffer buffer)
         {
            Match m;

            // Ugly hack since .NET doesn't have a flag for when the
            // end of the input string was encountered...
            buffer.Peek(1024 * 16);

            // Also, there is no API to limit the search to the specified
            // position, so we double-check the index afterwards instead.
            m = this.reg.Match(buffer.ToString(), buffer.Position);

            if (m.Success && m.Index == buffer.Position)
            {
               return m.Length;
            }
            else
            {
               return 0;
            }
         }
      }
   }
}
